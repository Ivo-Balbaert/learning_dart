// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * This library exports all of the commonly used functions and types for
 * building UI's. It is equivalent to the following imports:
 *
 *     import 'package:web_ui/observe.dart';
 *     import 'package:web_ui/safe_html.dart';
 *     import 'package:web_ui/templating.dart';
 *     import 'package:web_ui/watcher.dart';
 *     import 'package:web_ui/web_ui.dart' show WebComponent;
 *
 * Note that the [WebComponent] base class is defined in this library.
 *
 * See this article for more information:
 * <http://www.dartlang.org/articles/dart-web-components/>.
 */
library web_ui;

export 'observe.dart';
export 'safe_html.dart';
export 'templating.dart';
export 'watcher.dart';

import 'dart:async';
import 'dart:html';
import 'package:custom_element/custom_element.dart' show CustomElement;
import 'package:meta/meta.dart';

/**
 * The base class for all Dart web components. In addition to the [Element]
 * interface, it also provides lifecycle methods:
 * - [created]
 * - [inserted]
 * - [attributeChanged]
 * - [removed]
 */
abstract class WebComponent extends CustomElement {
  /** The web component element wrapped by this class. */
  Element _host;
  List _shadowRoots;

  /**
   * Shadow roots generated by dwc for each custom element, indexed by the
   * custom element tag name.
   */
  Map<String, dynamic> _generatedRoots = {};

  /** Any CSS selector (class, id or element) defined name to mangled name. */
  ScopedCssMapper _mapper = new ScopedCssMapper({});

  // TODO(terry): Add a mapper per component in the type hierarchy.
  ScopedCssMapper getScopedCss(String componentName) => _mapper;
  void setScopedCss(String componentName, var mapper) { _mapper = mapper; }

  /**
   * Temporary property until components extend [Element]. An element can
   * only be associated with one host, and it is an error to use a web component
   * without an associated host element.
   */
  Element get host {
    if (_host == null) throw new StateError('host element has not been set.');
    return _host;
  }

  set host(Element value) {
    if (value == null) {
      throw new ArgumentError('host must not be null.');
    }
    // TODO(jmesserly): xtag used to return "null" if unset, now it checks for
    // "this". Temporarily allow both.
    var xtag = value.xtag;
    if (xtag != null && xtag != value) {
      throw new ArgumentError('host must not have its xtag property set.');
    }
    if (_host != null) {
      throw new StateError('host can only be set once.');
    }

    value.xtag = this;
    _host = value;
  }

  /**
   * **Note**: This is an implementation helper and should not need to be called
   * from your code.
   *
   * Creates the [ShadowRoot] backing this component.
   */
  createShadowRoot([String componentName]) {
    var root = _createShadowRoot();
    if (componentName != null) {
      _generatedRoots[componentName] = root;
    }
    return root;
  }

  _createShadowRoot() {
    if (_realShadowRoot) {
      return host.createShadowRoot();
    }
    if (_shadowRoots == null) _shadowRoots = [];
    _shadowRoots.add(new DivElement());
    return _shadowRoots.last;
  }

  getShadowRoot(String componentName) => _generatedRoots[componentName];

  /**
   * Invoked when this component gets created.
   * Note that [root] will be a [ShadowRoot] if the browser supports Shadow DOM.
   */
  void created() {}

  /** Invoked when this component gets inserted in the DOM tree. */
  void inserted() {}

  /** Invoked when this component is removed from the DOM tree. */
  void removed() {}

  // TODO(jmesserly): how do we implement this efficiently?
  // See https://github.com/dart-lang/web-ui/issues/37
  /** Invoked when any attribute of the component is modified. */
  void attributeChanged(String name, String oldValue, String newValue) {}


  /**
   * **Note**: This is an implementation helper and should not need to be called
   * from your code.
   *
   * If [ShadowRoot.supported] or [useShadowDom] is false, this distributes
   * children to the insertion points of the emulated ShadowRoot.
   * This is an implementation helper and should not need to be called from your
   * code.
   *
   * This is an implementation of [composition][1] and [rendering][2] from the
   * Shadow DOM spec. Currently the algorithm will replace children of this
   * component with the DOM as it should be rendered.
   *
   * Note that because we're always expanding to the render tree, and nodes are
   * expanded in a bottom up fashion, [reprojection][3] is handled naturally.
   *
   * [1]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#composition
   * [2]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#rendering-shadow-trees
   * [3]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#reprojection
   */
  void composeChildren() {
    if (_realShadowRoot) return;

    if (_shadowRoots.length == 0) {
      // TODO(jmesserly): this is a limitation of our codegen approach.
      // We could keep the _shadowRoots around and clone(true) them, but then
      // bindings wouldn't be properly associated.
      throw new StateError('Distribution algorithm requires at least one shadow'
        ' root and can only be run once.');
    }

    var treeStack = _shadowRoots;

    // Let TREE be the youngest tree in the HOST's tree stack
    var tree = treeStack.removeLast();
    var youngestRoot = tree;
    // Let POOL be the list of nodes
    var pool = new List.from(nodes);

    // Note: reprojection logic is skipped here because composeChildren is
    // run on each component in bottom up fashion.

    var shadowInsertionPoints = [];
    var shadowInsertionTrees = [];

    while (true) {
      // Run the distribution algorithm, supplying POOL and TREE as input
      pool = _distributeNodes(tree, pool);

      // Let POINT be the first encountered active shadow insertion point in
      // TREE, in tree order
      var point = tree.query('shadow');
      if (point != null) {
        if (treeStack.length > 0) {
          // Find the next older tree, relative to TREE in the HOST's tree stack
          // Set TREE to be this older tree
          tree = treeStack.removeLast();
          // Assign TREE to the POINT

          // Note: we defer the actual tree replace operation until the end, so
          // we can run _distributeNodes on this tree. This simplifies the query
          // for content nodes in tree order.
          shadowInsertionPoints.add(point);
          shadowInsertionTrees.add(tree);

          // Continue to repeat
        } else {
          // If we've hit a built-in element, just use a content selector.
          // This matches the behavior of built-in HTML elements.
          // Since <content> can be implemented simply, we just inline it.
          _distribute(point, pool);

          // If there is no older tree, stop.
          break;
        }
      } else {
        // If POINT exists: ... Otherwise, stop
        break;
      }
    }

    // Handle shadow tree assignments that we deferred earlier.
    for (int i = 0; i < shadowInsertionPoints.length; i++) {
      var point = shadowInsertionPoints[i];
      var tree = shadowInsertionTrees[i];
      _distribute(point, tree.nodes);
    }

    // Replace our child nodes with the ones in the youngest root.
    nodes.clear();
    nodes.addAll(youngestRoot.nodes);

    // Because we polyfill composition and distribution,
    // 'getShadowRoot("this-component").query' will not behave correctly: we'll
    // either get no results if we keep youngestRoot as the associated root, or
    // we'll get a lot of results if we use this component as the new root. We
    // decided to do the latter.
    // TODO(sigmund): should these updates also be done for the other roots in
    // the tree stack?
    for (var componentName in _generatedRoots.keys) {
      if (_generatedRoots[componentName] == youngestRoot) {
        _generatedRoots[componentName] = this;
        break;
      }
    }
  }


  /**
   * This is an implementation of the [distribution algorithm][1] from the
   * Shadow DOM spec.
   *
   * [1]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#dfn-distribution-algorithm
   */
  List<Node> _distributeNodes(Element tree, List<Node> pool) {
    // Repeat for each active insertion point in TREE, in tree order:
    for (var insertionPoint in tree.queryAll('content')) {
      if (!_isActive(insertionPoint)) continue;
      // Let POINT be the current insertion point.

      // TODO(jmesserly): validate selector, as specified here:
      // http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#matching-insertion-points
      var select = insertionPoint.attributes['select'];
      if (select == null || select == '') select = '*';

      // Repeat for each node in POOL:
      //     1. Let NODE be the current node
      //     2. If the NODE matches POINT's matching criteria:
      //         1. Distribute the NODE to POINT
      //         2. Remove NODE from the POOL

      var matching = [];
      var notMatching = [];
      for (var node in pool) {
        (_matches(node, select) ? matching : notMatching).add(node);
      }

      if (matching.length == 0) {
        // When an insertion point or a shadow insertion point has nothing
        // assigned or distributed to them, the fallback content must be used
        // instead when rendering. The fallback content is all descendants of
        // the element that represents the insertion point.
        matching = insertionPoint.nodes;
      }

      _distribute(insertionPoint, matching);

      pool = notMatching;
    }

    return pool;
  }

  static bool _matches(Node node, String selector) {
    if (node is! Element) return selector == '*';
    return (node as Element).matches(selector);
  }

  static bool _isInsertionPoint(Element node) =>
      node.tagName == 'CONTENT' || node.tagName == 'SHADOW';

  /**
   * An insertion point is "active" if it is not the child of another insertion
   * point. A child of an insertion point is "fallback" content and should not
   * be considered during the distribution algorithm.
   */
  static bool _isActive(Element node) {
    assert(_isInsertionPoint(node));
    for (node = node.parent; node != null; node = node.parent) {
      if (_isInsertionPoint(node)) return false;
    }
    return true;
  }

  /** Distribute the [nodes] in place of an existing [insertionPoint]. */
  static void _distribute(Element insertionPoint, Iterable<Node> nodes) {
    assert(_isInsertionPoint(insertionPoint));
    insertionPoint.parent.insertAllBefore(nodes, insertionPoint);
    insertionPoint.remove();
  }

  // TODO(jmesserly): rename "created" to "onCreated".
  void onCreated() => created();
}

/**
 * Maps CSS selectors (class and) to a mangled name and maps x-component name
 * to [is='x-component'].
 */
class ScopedCssMapper {
  final Map<String, String> _mapping;

  ScopedCssMapper(this._mapping);

  /** Returns mangled name of selector sans . or # character. */
  String operator [](String selector) => _mapping[selector];

  /** Returns mangled name of selector w/ . or # character. */
  String getSelector(String selector) {
    var prefixedName = this[selector];
    var selectorType = selector[0];
    if (selectorType == '.' || selectorType == '#') {
      return '$selectorType${prefixedName}';
    }

    return prefixedName;
  }
}

/**
 * Set this to true to use native Shadow DOM if it is supported.
 * Note that this will change behavior of [WebComponent] APIs for tree
 * traversal.
 */
bool useShadowDom = false;

bool get _realShadowRoot => useShadowDom && ShadowRoot.supported;

/**
 * Set this to the [Element] to be used as the root for the Web UI app.
 */
Element webUIRoot = document.body;
